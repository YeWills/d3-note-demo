<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <!-- <link rel="stylesheet" href="./style.css"> -->
    <link rel="stylesheet" href="./style copy.css">
</head>
<body>
<script src="./d3js.js"></script>
<script>

         var width = 800,
         height = 600;
         var padding = {left:80,right:50,top:20,bottom:20};


    var svg = d3.select("body").append("svg")
            .attr("width", width + padding.right + padding.left)
            .attr("height", height + padding.top + padding.bottom)
            .append("g")
            .attr("transform", "translate(" + padding.left + "," + padding.top + ")");


        var tree = d3.layout.tree()
            .size([height, width]);

    // diagonal 生成对角线
    var diagonal = d3.svg.diagonal()
    // 转换坐标轴方向
            .projection(function(d) { 
                    return [d.y, d.x]; 
                    });


    d3.json("./flare.json", function(err, root) {
        if (err) throw err;

        root.x0 = height / 2;
        root.y0 = 0;

//         function collapse(d) {
//             if (d.children) {
//                 d._children = d.children;
//                 d._children.forEach(collapse);
// //                d.children = null;
//             }
//         }

//         root.children.forEach(collapse);
redraw(root);


function redraw(source){


// Compute the new tree layout.
var nodes = tree.nodes(root),
        links = tree.links(nodes);

// Normalize for fixed-depth.
//当节点的层级变动的时候，依然保证节点的位置美观
//depth 层级的意思，有 1 2 3 。。。
nodes.forEach(function(d) { 
  d.y = d.depth * 180; 
});



// Update the nodes…
var nodeUpdate = svg.selectAll(".node")
        .data(nodes, d=>d.name);

        var nodeEnter = nodeUpdate.enter()
        var nodeExit = nodeUpdate.exit()

// Enter any new nodes at the parent's previous position.
var enterNodes = nodeEnter.append("g")
        .attr("class", "node")
        .attr("transform", function(d) {
                console.log(source.y0)
                return "translate(" + source.y0 + "," + source.x0 + ")"; 
                })
                .on('click', (d)=>{
                        toggle(d);
                        redraw(d);
                })

enterNodes.append('circle')
          .attr('r', 0)
          .style('fill', (d)=>d._children ? 'red' : '#fff')

          enterNodes.append('text')
                   .text(d=>d.name)
                   .attr('dx', d=>d.children || d._children ? 'end' : 'start')
                   .style('fill-opacity', 0)

                   var updateNodes = nodeUpdate.transition()
                   .duration(500)
                   .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; })

updateNodes.select("circle")
        .attr("r", 6)
        .style("fill", function(d) { return d._children ? "red" : "#fff"; });
        updateNodes.select("text")
        .style("fill-opacity", 1);
// Transition exiting nodes to the parent's new position.
var exitNodes = nodeExit.transition()
        .duration(500)
        .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
        .remove();

        exitNodes.select("circle")
        .attr("r", 0);

        exitNodes.select("text")
        .style("fill-opacity", 0);




// Update the links…
var linkUpdate = svg.selectAll(".link")
        .data(links, function(d) { return d.target.name; });
        var linkEnter = linkUpdate.enter();
        var linkExit = linkUpdate.exit();

// Enter any new links at the parent's previous position.
linkEnter.insert("path", ".node")
        .attr("class", "link")
        .attr("d", function(d) {
            var o = {x: source.x0, y: source.y0};
            return diagonal({source: o, target: o});
        })
        .transition()
        .duration(500)
        .attr("d", diagonal);

        linkUpdate.transition()
        .duration(500)
        .attr('d', diagonal)

// Transition exiting nodes to the parent's new position.
linkExit.transition()
        .duration(500)
        .attr("d", function(d) {
            var o = {x: source.x, y: source.y};
            return diagonal({source: o, target: o});
        })
        .remove();

        // Stash the old positions for transition.
nodes.forEach(function(d) {
    d.x0 = d.x;
    d.y0 = d.y;
});

}




function toggle(d) {
        if (d.children) {
            d._children = d.children;
            d.children = null;
        } else {
            d.children = d._children;
            d._children = null;
        }
        // update(d);
    }
    });

//    d3.select(self.frameElement).style("height", "800px");

   

</script>
</body>
</html>


